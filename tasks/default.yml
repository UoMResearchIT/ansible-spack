---
- name: Install OS package dependencies
  become: yes
  become_user: root
  with_items: '{{ spack_dep_pkgs | default([]) }}'
  loop_control:
    loop_var: spack_os_pkg
  package:
    state: present
    name: '{{ spack_os_pkg }}'

- name: Create a Spack service user.
  user:
    name: '{{ spack_service_user }}'
    home: /var/lib/{{ spack_service_user }}
    shell: /sbin/nologin

# Not sure if this will be necessary.  Leaving it in for now. 
# In the conda role, this is used for regularly backing up conda envs.
#- name: Ensure that service user's name and e-mail are configured for git.
#  become: yes
#  become_user: '{{ spack_service_user }}'
#  template:
#    src: gitconfig.j2
#    dest: /var/lib/{{ spack_service_user }}/.gitconfig

- name: Check for installation of Spack
  become: yes
  stat:
    path: '{{ spack_install_dir }}/bin/spack'
  changed_when: false
  register: spack_binary

- when: not spack_binary.stat.exists
  block:
    # We don't want to run the risk of accidentally performing a git pull, so the git repo and work tree are separate.  We only pull down the last commit.
    # See here: https://cornell-ssw.github.io/cluster_administration.html#understanding-spack
    # At this point, the best way to upgrade Spack (if desired) is to blow it away and perform a fresh install, perhaps using a lock file for the old environment.
    - name: Clone spack
      become: yes
      become_user: root
      command: "/usr/bin/git --work-tree={{ spack_install_dir }} clone --branch={{ spack_ver }} --depth=1 {{ spack_repo }} {{ spack_install_dir }}/src"
      async: '{{spack_timeout_seconds}}'
      poll: 5

    - name: Change ownership of install directory to service account
      file:
        path: '{{ spack_install_dir }}'
        owner: '{{ spack_service_user }}'
        group: '{{ spack_service_user }}'
        state: directory
        recurse: yes
        follow: no

    # Necessary?  What's the default umask?
    - name: Change permissions of install directory 
      file:
        path: '{{ spack_install_dir }}'
        state: directory
        mode: 0755

# At this point only the service account can do anything, so most commands run by end-users will barf.
- name: Add Spack to universal bash profile.
  become: yes
  become_user: root
  when: spack_make_sys_default and not spack_binary.stat.exists
  template:
    src: spack-env.sh.j2
    dest: /etc/profile.d/spack-env.sh

# TODO- Revisit this after making this role work for a traditional gatekeeper model.
## All directories / files will be owned by the service user's group
## so that it can read/write as necessary for various back-up and other maintenance operations.
#- name: Create centralized location for user environments and package caches.
#  become: yes
#  become_user: root
#  file:
#    path: '{{ spack_user_storage }}'
#    owner: '{{ spack_service_user }}'
#    group: '{{ spack_service_user }}'
#    state: directory
#    mode: 02777

- name: Initialize Spack environmment
  become: yes
  become_user: '{{ spack_service_user }}'
  command: "/bin/bash /etc/profile.d/spack-env.sh"

# If we don't have gcc 8, various Spack commands for installing / mirroring compilers will crap out, since LLVM requires gcc 8 instead
# of the the CentOS 7 default (4.8.5).  Even for mirroring, Spack seems to concretize for some reason.
- name: If running a version of RHEL/CentOS before 8, add gcc 8 to compilers.
  become: yes
  become_user: '{{ spack_service_user }}'
  command: /bin/scl enable devtoolset-8 "{{ spack_install_dir }}/bin/spack compiler find"
  when: ansible_os_family == "RedHat" and ansible_distribution_major_version < '8'

- name: Add the package mirror as a default mirror globally.
  become: yes
  become_user: '{{ spack_service_user }}'
  command: "{{ spack_install_dir }}/bin/spack mirror add local file://{{ spack_mirror_dir }} --scope defaults"
  when: spack_mirror_pkgs is defined   

#- name: Generate commands for mirroring source code and setting up a base environment.
#  set_fact:
#    spack_mirror_cmds: "[ {% for item in spack_mirror_pkgs %}'{{ spack_install_dir }}/bin/spack mirror create -D -d {{ spack_mirror_dir }} -n all {{ item }}', {% endfor %} ]"
#    spack_base_env_cmds: "[ {% for item in spack_base_env %}'{{ spack_install_dir }}/bin/spack install {{ item }}', {% endfor %} ]"
#
#- name: Print Spack commands that will be run
#  debug:
#    msg: "Commands to be run: {{ spack_mirror_cmds + spack_base_env_cmds }}"

- name: Make a package mirror / local cache of source code for all versions of key packages and their dependencies.
  become: yes
  become_user: '{{ spack_service_user }}'
  with_items: "{{ spack_mirror_pkgs }}"
  when: spack_mirror_pkgs is defined
  command: "{{ spack_install_dir }}/bin/spack mirror create -D -d {{ spack_mirror_dir }} -n all {{ item }}"
  async: '{{spack_timeout_seconds}}'
  poll: 120

# This takes a long time because compiling compilers takes a long time.
# Because of this we have it run asynchronously.
# Anecdotal reference:
# https://unix.stackexchange.com/questions/421822/how-long-does-it-take-to-compile-gcc-7-3-0
- name: Install base environment packages.
  become: yes
  become_user: '{{ spack_service_user }}'
  with_items: "{{ spack_base_env }}"
  when: spack_base_env is defined
  command: "{{ spack_install_dir }}/bin/spack install {{ item }}"
  async: '{{spack_timeout_seconds}}'
  poll: 120
